DP集
----------------------------------------------


# dpデバッグ用
void writeDP(int _i, int _j) {
	printf("i|j ");
	rep(j, 0, _j) printf("|%4d", j);
	printf("\n-----");
	rep(i, 0, _j) printf("-----");
	printf("\n");
	rep(i, 0, _i) {
		printf("%4d", i);
		rep(j, 0, _j) printf("|%4lld", dp[i][j]);
		printf("\n");
	}
	printf("\n");
}










## DP
””並び方を工夫して、同一状態として考えられないかを考えよう””
Nが小さい → 2^N系？ → bitDPかも
””まず全状態で何個あるか考えてみる””
その個数によっては、DPでごり押せる
””貪欲法で行けないかを確かめてからDPしよう””
AOJ 2298
””DPの要素を何にするかを考えるときは、数の大きさを参考にしよう””
DPでしか解けないような数の大きさ（合計で10^6位）に設定してあるはず。
AOJ 2156
1 <= N <= 10^2
1 <= HP <= 10^5
1 <= M <= 10^2
1 <= MP <= 10^2
1 <= Damage <= 10^6
この場合、
1次元なら dp[HP]かdp[Damage]
2次元なら dp[N][M]かdp[M][MP]かdp[MP][N]
3次元なら dp[N][M][MP]
の候補が考えられる



## 文字列でDPを使うのはよくある




## 括弧の対応を用いた数え上げは、dp[文字列の長さ][その文字列内での余分な(の数]のように、(の数だけを保持しつつ書き上げていけばよい。



## 通る順番が決まっている最短経路はDP


## 数列内のある区画にある数が存在しないことを見るDP
vi dp(n, 0);
rep(i, 1, n)
{
	if (a[i] == a[i - 1])
		dp[i] = dp[i - 1];
	else
		dp[i] = i;
}
これでDPを作る



## 桁DP
dp[何桁目][閾値未満か(0or1)][条件1][条件2]・・・
2番目の要素は閾値が指定されている場合に使用する
n桁分あって条件を満たす数を数え上げる場合は桁DP

## dpで決める順が関係ない -> 決まった個数が添字に入る（割と頻出）


## bitDPにおいて、maskの部分集合を列挙したい時
for(int mask2 = mask;mask2 > 0;mask2 = (mask2 - 1) & mask)
maskの部分集合とは、mask = 1011であれば、その部分集合は
mask2 = {1011, 1010, 1001, 1000, 0011, 0010, 0001}である
