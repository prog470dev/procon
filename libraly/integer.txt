整数関係
----------------------------------------------








## ユークリッドで最大公約数を求める
int gcd(int a, int b) { return a ? gcd(b%a, a) : b; }
ll gcd(ll a,ll b){return a?gcd(b%a,a):b;}

## 最大公約数を用いて、最小公倍数を求める
ll lcm(ll a,ll b){return a / gcd(a,b) * b;}





## 階乗
#define FAC_MAX 200001
ll fac_memo[FAC_MAX];
int fac_memo_max = 0;

ll fac(ll a)
{
	if (a <= fac_memo_max) return fac_memo[a];

	rep(i, fac_memo_max + 1, a + 1)
	{
		fac_memo[i] = fac_memo[i - 1] * i;
	}

	fac_memo_max = a;

	return fac_memo[a];
}
fac_memo[0] = 1;




## 組み合わせ
ll aCb(ll a, ll b)
{
	if (a < b) return 0;
	return fac(a) / (fac(a - b) * fac(b));
}



## 重複組合せ
## n種類のものの中から重複を許してk個を選ぶ
ll nHk(ll n, ll k)
{
	return aCb(n + k - 1, k);
}
##
重複組合せ：例
• 以下の条件を満たす整数の組 (x1, ..., xn) は何通りあるか？
– xi >= ai
– x1 + … + xn = s

• x'i = xi - ai, s' = s - (a1 + … + an) とおくと，
x'1 + … + x'n = s' を満たす非負整数の組 (x'1, ..., x'n) を数える問題になる

• nHs' 通り
##



## 高速累乗
ll fastpow(ll x, ll n) {
    ll ret = 1;
    while (0 < n) {
        if ((n % 2) == 0) x *= x, n >>= 1;
        else ret *= x, --n;
    }
    return ret;
}



## string → long long
ll _stoi(string x)
{
	ll ret = 0;
	rep(i, 0, x.length()) ret = ret * 10 + x[i] - '0';
	return ret;
}


## _min～_maxでmodの倍数である個数を数える
ll countMod(ll _min, ll _max, ll mod)
{
	if (_max % mod == 0)
	{
		if (_min % mod == 0)
			return _max / mod - _min / mod + 1;
		else
			return _max / mod - _min / mod;
	}
	else
	{
		if(_min % mod == 0)
			return _max / mod - _min / mod + 1;
		else
			return _max / mod - _min / mod;
	}
}

## 約数列挙
vector<ll> enumdiv(ll n) {
	vector<ll> S;
	for (ll i = 1; i*i <= n; i++) if (n%i == 0) { S.push_back(i); if (i*i != n) S.push_back(n / i); }
	sort(S.begin(), S.end());
	return S;
}
// divs[i] := iの約数の集合 [1,N]の約数列挙をO(NlogN)でやれるやつ
    rep(i, 1, 101010) for (int j = i; j < 101010; j += i) divs[j].push_back(i);




## 素因数分解
map<ll,int> enumpr(ll n) {
	map<ll,int> V;
	for(ll i=2;i*i<=n;i++) while(n%i==0) V[i]++,n/=i;
	if(n>1) V[n]++;
	return V;
}
map<int, int> enumpr(int n) {
    map<int, int> V;
    for (int i = 2; i*i <= n; i++) while (n%i == 0) V[i]++, n /= i;
    if (n>1) V[n]++;
    return V;
}

## 素因数分解して素因数毎の個数だけ得る関数
例) fastPrimeFactorization(24) = {1, 3} // 3^1*2^3なので
#define PMAX 1010101
int minP[PMAX];
void fastPrimeFactorizationPre() {
	for (int i = 0; i <= PMAX; i++) {
		minP[i] = i;
	}
	for (int i = 2; i <= PMAX; i++) {
		if (minP[i] == i) {
			for (int j = i * 2; j <= PMAX; j += i) {
				minP[j] = i;
			}
		}
	}
}
vector<int> fastPrimeFactorization(int n) {
	vector<int> ret;
	while (n != 1) {
		int cnt = 0;
		int u = minP[n];
		while (n % u == 0) {
			cnt++;
			n /= u;
		}
		if (cnt > 0) {
			ret.push_back(cnt);
		}
	}
	return ret;
}



# 素数判定
bool isprime(int v) {
	if (v == 1) return false;
	for (int i = 2; i*i <= v; i++) if (v%i == 0) return false;
	return true;
}






typedef long long ll;
ll extgcd(ll a, ll b, ll &x, ll &y) {
    ll g = a; x = 1; y = 0;
    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;
    return g;
}
ll gcd(ll a, ll b) { return a ? gcd(b%a, a) : b; }
ll mod_inverse(ll a, ll m) { // 制約gcd(a,m)=1
    ll x, y;
    extgcd(a, m, x, y);
    return (m + x % m) % m;
}
int solve(int a, int b, int m) { // ax=b(mod m) でxを求める
    ll x, y; int d = extgcd(a, m, x, y);
    if (b%d != 0)return -1;
    return (1LL * b / d*x%m + m) % m;
}





// 上限INFの掛け算
typedef long long ll;
typedef long double ld;
#define INF 1LL<<60
ll mul(ll a, ll b) {
    ld aa = logbl(a), bb = logbl(b), inf = logbl(INF);
    if (inf < aa + bb) return INF;
    ll res = a * b;
    return min(INF, res);
}
