コンテナ
----------------------------------------------

## 比較

型				| ランダムアクセスの時間	| 挿入・削除の時間			| 検索の時間
vector			| O(1)				| O(1)（末尾） O(n)（他）		| O(n)
deque			| O(1)				| O(1)（挿入か末尾）		| O(n)
				|					| O(n)（他）				|
list			| O(n)				| O(1)					| O(n)
map, multimap	| O(log n)			| O(log n)				| O(n)




## stack
メソッド pop(), push(a), top(), empty(), size()
topは一番上を見るだけ




## 比較関数
first昇順、second昇順の場合
bool comp(pii a, pii b)
{
	if(a != b)
		return a.first < b.first;
	else
		return a.second < b.second;
}
sort(A.begin(), A.end(), comp)



## 降順ソート
vector<int> A;
sort(A.begin(), A.end(), greater<int>());





## tuple
tuple<???,???,???>で作る
make_tuple使える
get<0>(tuple)とかget<1>(tuple)で取得



## bound系
### ソート済みベクタAの中でB以上の要素が最初に現れる位置
    lower_bound(A.begin(),A.end(),B);
### ソート済みベクタAの中でBより大きい要素が最初に現れる位置
    upper_bound(A.begin(),A.end(),B);
### iteのインデックスを返す
    distance(A.begin(), ite)



## vectorでfind
auto iter = std::find(vec.begin(), vec.end(), value);



## vectorでindex返すfind
int find_index(vector<int> a, int x)
{
	if (a.size() == 0) return -1;

	int l = 0;
	int r = a.size();
	while (l + 1 != r)
	{
		int mid = (l + r) / 2;
		if (a[mid] <= x)
			l = mid;
		else
			r = mid;
	}
	if (a[l] == x)
		return l;
	else
		return -1;
}



## 全ての組み合わせを試す
vector<char> vc = {'+', '-', '*'};
sort(vc.begin(), vc.end());
do
{
	cout << vc[0] << "," << vc[1] << "," << vc[2] << endl;
} while (next_permutation(vc.begin(), vc.end()));


## setのiterator

進む next(ite)
戻る prev(ite)
