/*
いもす法(1次元、2次元)

概要：累積和を用いて複数要素の重なり、深さを求める
○1次元:開始部分を+1、終了部分の次を-1

例)0時から12時の間で、2時から6時、4時から9時に客がいた
初期状態：[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
2時から6時：[0, 0, 1, 0, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0]
4時から9時：[0, 0, 1, 0, 1, 0, 0,-1, 0, 0,-1, 0, 0, 0]
和を求める：[0, 0, 1, 1, 2, 2, 2, 1, 1, 1, 0, 0, 0, 0]

○2次元：(x1, y1)～(x2, y2)の範囲が与えられたら、
　　　(x1, y1)を+1、(x2+1, y2+1)を+1、(x2+1, y1)を-1、(x1, y2+1)を-1

例)(0, 0)～(3, 3)の範囲で(1, 1)～(2, 3)、(1, 0)～(3, 2)の範囲に関する重なり
   [0, 0, 0, 0, 0]　[0, 0, 0, 0, 0]　[0, 0, 0, 0, 0]
   [0, 0, 0, 0, 0]　[0, 1, 0, 0,-1]　[1, 1, 0,-1,-1]
   [0, 0, 0, 0, 0]⇒[0, 0, 0, 0, 0]⇒[0, 0, 0, 0, 0]
   [0, 0, 0, 0, 0]　[0,-1, 0, 0, 1]　[0,-1, 0, 0, 1]
   [0, 0, 0, 0, 0]　[0, 0, 0, 0, 0] [-1, 0, 0, 1, 0]

   　→方向に加算　　　↓方向に加算
   [0, 0, 0, 0, 0]　[0, 0, 0, 0, 0]　
   [1, 2, 2, 1, 0]　[1, 2, 2, 1, 0]　
 ⇒[0, 0, 0, 0, 0]⇒[1, 2, 2, 1, 0]　
 　[0,-1,-1,-1, 0]　[1, 1, 1, 0, 0]　
  [-1,-1,-1, 0, 0]　[0, 0, 0, 0, 0]　


計算量：1次元での要素の個数をN、範囲をLとすると
		Ｏ(N * L)　⇒　Ｏ(N + L)
		2次元での要素の個数をN、範囲をH*Wとすると
		Ｏ(N * H * W)　⇒　Ｏ(N + H * W)

注意：配列のサイズは1つ大きくとる

実装例：
○1次元
void Imos1() {
	vector<int> vi1(L + 1, 0);
	vector<pair<int, int>> vp;

	// 範囲(l, r)を入力(l<=r)
	vp.emplace_back(l, r);
	//...

	// 範囲内なら+1, 範囲外なら-1
	for (int i = 0; i < vp.size(); i++) {
		vi1[vp[i].first]++;
		vi1[vp[i].second + 1]--;
	}
	// 累積和を求める
	for (int i = 1; i < vi1.size(); i++) {
		vi1[i] += vi1[i - 1];
	}

	// nでの重なりを求めたいとき
	// ... = vi1[n]
}

○2次元
void Imos2() {
	vector<vector<int>> vi2(H + 1, vector<int>(W + 1));
	vector<pair<int, int>> vp1;  // y1, x1;
	vector<pair<int, int>> vp2;  // y2, x2;

	// 範囲(y1, x1)～(y2, x2)を入力(y1<=y2, x1<=x2, vp1.size()==vp2.size())
	vp1.emplace_back(y1, x1);
	vp2.emplace_back(y2, x2);
	// ...

	// 範囲内なら+1, 範囲外なら-1
	for (int i = 0; i < vp1.size(); i++) {
		vi2[vp1[i].first][vp1[i].second]++;
		vi2[vp2[i].first + 1][vp2[i].second + 1]++;
		vi2[vp1[i].first][vp2[i].second + 1]--;
		vi2[vp2[i].first + 1][vp1[i].second]--;
	}
	// 累積和を求める
	for (int i = 0; i < vi2.size(); i++) {
		for (int j = 1; j < vi2[i].size(); j++) {
			vi2[i][j] += vi2[i][j - 1];
		}
	}
	for (int j = 0; j < vi2[0].size(); j++) {
		for (int i = 1; i < vi2.size(); i++) {
			vi2[i][j] += vi2[i - 1][j];
		}
	}

	// (y, x)での重なりを求めたいとき
	// ... = vi2[y][x]
}

*/
